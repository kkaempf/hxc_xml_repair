#!/usr/bin/env ruby

# Copyright (c) Klaus KÃ¤mpf 2021
#
# Licensed under the MIT License

# How to use
#
# hxc_xml_gen 
#
# hxc_xml_gen 1024 5 2 80 d80dsdd.img - generate 80 tracks, double sided, 5 sectors a 1024 bytes
#

require 'nokogiri'

def help message=nil
  STDERR.puts "Err: #{message}" if message
  STDERR.puts "Usage:"
  STDERR.puts "  hxc_xml_gen <sector_size> <sectors_per_track> <sides> <tracks> <image_file>"
  STDERR.puts "\tgenerates HxC XML files from (flat) image files"
  exit ((message)?1:0)
end

def add_node parent, name, content = nil
  node = Nokogiri::XML::Node.new(name, parent.document)
  node.content = content if content
  parent.add_child node
  node
end

sector_size = ARGV.shift.to_i
if sector_size.nil?
  help "Sector size invalid or missing"
end
sectors_per_track = ARGV.shift.to_i
if sectors_per_track.nil?
  help "Sector per track invalid or missing"
end
sides = ARGV.shift.to_i
if sides.nil?
  help "Sides invalid or missing"
end
tracks = ARGV.shift.to_i
if tracks.nil?
  help "Tracks invalid or missing"
end

unless [128,256,512,1024].include? sector_size
  help "Invalid sector size: #{sector_size}"
end
unless [1,2].include? sides
  help "Invalid sides value: #{sides}"
end
sectors_per_side = sectors_per_track / sides

if sectors_per_side * sides != sectors_per_track
  help "Sectors per track across both sides please"
end

if sectors_per_side * sector_size > 5*1024
  help "Too many sectors per track"
end
if sectors_per_side * 128 < 26
  help "Too few sectors per track"
end

image_name = ARGV.shift

expected_image_size = tracks * sides * sectors_per_side * sector_size
actual_image_size = File.size(image_name)
if expected_image_size != actual_image_size
  help "Expected image size #{expected_image_size} is not matching actual image size #{actual_image_size}"
end

document = Nokogiri::XML::Document.new

File.open(image_name) do |image|
  # <disk_layout>
  #   <disk_layout_name>AUTOGENERATEDLAYOUT</disk_layout_name>
  #   <disk_layout_description>Auto Generated Disk Layout</disk_layout_description>
  #   <prefered_file_extension>img</prefered_file_extension>
  #   <interface_mode>GENERIC_SHUGART_DD_FLOPPYMODE</interface_mode>
  #   <file_size>258944</file_size>
  #   <layout>
  #     <number_of_track>80</number_of_track>
  #     <number_of_side>1</number_of_side>
  #     <format>IBM_FM</format>
  #     <start_sector_id>1</start_sector_id>
  #     <sector_per_track>26</sector_per_track>
  #     <sector_size>128</sector_size>
  #     <formatvalue>0</formatvalue>
  #     <gap3>255</gap3>
  #     <bitrate>499733</bitrate>
  #     <pregap>0</pregap>
  #     <rpm>359</rpm>

  disk_layout = add_node(document, "disk_layout")
  add_node(disk_layout, "disk_layout_name", "AUTOGENERATEDLAYOUT")
  add_node(disk_layout, "disk_layout_description", "Auto generated from #{File.basename(image_name)} by hxc_xml_gen")
  add_node(disk_layout, "prefered_file_extension", "img")
  add_node(disk_layout, "interface_mode", "GENERIC_SHUGART_DD_FLOPPYMODE")
  add_node(disk_layout, "file_size", actual_image_size.to_s)
  layout = add_node(disk_layout, "layout")
  add_node(layout, "number_of_track", tracks.to_s)
  add_node(layout, "number_of_side", sides.to_s)
  add_node(layout, "format", "IBM_MFM")
  add_node(layout, "start_sector_id", 0)
  add_node(layout, "sector_per_track", sectors_per_side)
  add_node(layout, "sector_size", sector_size.to_s)
  add_node(layout, "formatvalue", 0)
  add_node(layout, "gap3", 255)
  add_node(layout, "bitrate", 250000)
  add_node(layout, "pregap", 0)
  add_node(layout, "rpm", 300)
  
  # <track_list>
  #   <track track_number="00" side_number="0">
  #     <data_offset>0x000000</data_offset>
  #     <format>IBM_MFM</format>

  (1..tracks).each do |track_number|
    (1..sides).each do |side_number|
      track_list = add_node(layout, "track_list")
      track_node = add_node(track_list, "track")
      track_node["track_number"] = "%02d" % (track_number - 1)
      track_node["side_number"] = side_number - 1
      data_offset = image.tell
      add_node(track_node, "data_offset", "0x%06x" % data_offset)
      add_node(track_node, "format", "IBM_MFM")
      
      # <sector_list>
      #   <sector sector_id="0" sector_size="1024">
      #     <sector_data>...</sector_data>
      #     <datamark>0xFB</datamark>
      #     <data_offset>0x000000</data_offset>
      #   </sector>          
      sector_list = add_node(track_node, "sector_list")
      sector_id = 0
      skew = ENV['SKEW'].atoi rescue 1
      if skew
        if skew < 1 || skew >= sectors_per_side
          STDERR.puts "Illegal SKEW"
          skew = 1
        end
      end
      sector_number = 1
      (1..sectors_per_side).each do
        sector_data = image.sysread(sector_size)
        sector_node = add_node(sector_list, "sector")
        sector_node["sector_id"] = sector_id
        sector_id += 1
        sector_node["sector_size"] = sector_size
        add_node(sector_node, "sector_data", sector_data.split('').map{|c| "%02X" % c.ord}.join(''))
        add_node(sector_node, "datamark", "0xFB")
        add_node(sector_node, "data_offset", "0x%06x" % data_offset)
        data_offset = image.tell
        sector_number = (sector_number + skew) % sectors_per_side
      end
    end
  end
end

puts document.to_s
